<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowDo - Learning & Notes</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import Map to load React modules from the web -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
      }
    </script>
    
    <!-- Babel to translate JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #09090b; }
        /* Custom scrollbar */
        textarea::-webkit-scrollbar { width: 4px; }
        textarea::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useMemo, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
          CheckCircle, Circle, X, Plus, Trash2, Lock, Unlock, Play, Settings, 
          MousePointer2, CornerDownRight, Unplug, StickyNote, Lightbulb, GitBranch, 
          GripHorizontal, BoxSelect, Download, Paperclip, FileText, Save, Database, 
          Link as LinkIcon, Image as ImageIcon, FolderOpen, Sparkles, Zap, BrainCircuit, Wand2,
          BookOpen, GraduationCap, HelpCircle, FileJson, Presentation, FileSearch,
          Library, Mic, CheckSquare, Music
        } from 'lucide-react';

        // --- Types & Constants ---
        const GRID_SIZE = 20;
        const DEFAULT_NODE_WIDTH = 260;
        const DEFAULT_NODE_HEIGHT = 180;
        const DB_NAME = 'FlowDoDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'appState';
        const STATE_KEY = 'current_flow';
        const SETTINGS_KEY = 'flowdo_settings';

        const COLORS = {
          bg: '#111111',
          grid: '#222222',
          nodeBg: '#1a1a1a',
          nodeHeaderTask: '#2563eb', // Blue
          nodeHeaderGoal: '#059669', // Green
          nodeHeaderLecture: '#7c3aed', // Violet
          nodeHeaderConcept: '#0891b2', // Cyan
          nodeHeaderQuestion: '#be123c', // Rose
          nodeHeaderSummary: '#d97706', // Amber
          nodeHeaderResource: '#4b5563', // Gray
          groupHeader: 'rgba(255, 255, 255, 0.1)',
          groupBg: 'rgba(255, 255, 255, 0.02)',
          text: '#e5e7eb',
          wire: '#ffffff',
          wireActive: '#4ade80',
          wireLocked: '#ef4444',
          wireSelected: '#3b82f6',
          selection: 'rgba(59, 130, 246, 0.5)'
        };

        const initialNodes = [
          { id: '1', type: 'lecture', title: 'Physics 101: Mechanics', x: 100, y: 300, width: 260, height: 160, completed: false, data: { label: 'Chapter 1: Newton\'s Laws\nProf. Smith', attachments: [] } },
          { id: '2', type: 'concept', title: 'Newton\'s First Law', x: 450, y: 150, width: 260, height: 180, completed: false, data: { label: 'An object remains at rest or in uniform motion unless acted upon by a force.', attachments: [] } },
          { id: '3', type: 'question', title: 'Quiz Prep', x: 450, y: 450, width: 260, height: 160, completed: false, data: { label: 'What is the difference between mass and weight?', attachments: [] } },
          { id: '4', type: 'summary', title: 'Lecture Summary', x: 800, y: 300, width: 280, height: 200, completed: false, data: { label: 'Key takeaways:\n1. Inertia matches mass\n2. F=ma is crucial\n3. Action = Reaction', attachments: [] } },
        ];

        const initialEdges = [
          { id: 'e1', source: '1', target: '2' },
          { id: 'e2', source: '1', target: '3' },
          { id: 'e3', source: '2', target: '4' },
          { id: 'e4', source: '3', target: '4' },
        ];

        const initialGroups = [
          { id: 'g1', title: 'Week 1 Material', x: 50, y: 100, width: 1100, height: 600, color: 'rgba(255, 255, 255, 0.1)' }
        ];

        // --- AI Helper Functions ---
        const MOCK_AI_RESPONSES = {
          explain: "Inertia is the resistance of any physical object to any change in its velocity.",
          quiz: ["Q: Formula for Force? (A: F=ma)", "Q: Net force if acc=0? (A: Zero)", "Q: Mass change on moon? (A: No)"],
          decompose: ["Review Ch.2", "Watch video", "Practice set", "Summary"],
          brainstorm: ["Mind map", "Real-world examples", "History", "Derivation"],
          enhance: "Focus on: \n- Defining system boundaries\n- Identifying external forces\n- Vector addition.",
          resources: ["Book: 'Concepts of Physics' by H.C. Verma", "Video: Khan Academy - Newton's Laws", "Site: Physics Classroom"],
          critique: "Grade: B+\n\nFeedback:\n- Good definition of inertia.\n- You missed the distinction between inertial and non-inertial frames.\n- Add an example about seatbelts.",
          transcribe: "[Audio Transcript]: The professor is discussing the third law. Action and reaction pairs act on different objects, never the same object...",
          flow: [
            { id: 1, title: 'Intro', type: 'lecture', description: 'Topic Overview', dependsOn: [] },
            { id: 2, title: 'Concept', type: 'concept', description: 'Main Theory', dependsOn: [1] }
          ]
        };

        const generateAIContent = async (mode, prompt, apiKey, attachment = null) => {
          if (!apiKey || apiKey === 'demo') {
            await new Promise(r => setTimeout(r, 1000));
            if (MOCK_AI_RESPONSES[mode]) return MOCK_AI_RESPONSES[mode];
            return [];
          }

          try {
            let userPrompt = "";
            let contextMessage = "";

            if (attachment) {
                if (attachment.fileType === 'text') contextMessage = `\n\n[File Content]:\n${attachment.content}\n\n`;
                else if (attachment.fileType === 'image') contextMessage = `\n\n[Attached Image] Analyze this image.`;
                else if (attachment.fileType === 'audio') contextMessage = `\n\n[Attached Audio] Listen to this audio.`;
            }

            if (mode === 'explain') userPrompt = `Explain "${prompt}" clearly.${contextMessage}`;
            else if (mode === 'quiz') userPrompt = `Generate 3 short quiz questions (with answers) for: "${prompt}"${contextMessage}. Return ONLY a JSON array of strings.`;
            else if (mode === 'enhance') userPrompt = `Improve and expand this note: "${prompt}"${contextMessage}`;
            else if (mode === 'critique') userPrompt = `Act as a strict professor. Grade this note/answer (A-F) and provide specific constructive feedback: "${prompt}"${contextMessage}`;
            else if (mode === 'transcribe') userPrompt = `Transcribe and summarize the key points from this audio.${contextMessage}`;
            else if (mode === 'resources') userPrompt = `Suggest 3 specific learning resources (Books, Videos, Articles) for: "${prompt}"${contextMessage}. Return ONLY a JSON array of strings.`;
            else if (mode === 'flow') userPrompt = `Create a study plan for: "${prompt}". Return JSON object with "steps" array (id, title, type, description, dependsOn). 5 steps. No markdown.`;
            else userPrompt = `Generate 3 sub-tasks/ideas for: "${prompt}"${contextMessage}. Return ONLY a JSON array of strings.`;

            const parts = [{ text: userPrompt }];
            
            if (attachment && (attachment.fileType === 'image' || attachment.fileType === 'audio') && attachment.url) {
                const base64Data = attachment.url.split(',')[1];
                const mimeType = attachment.url.split(';')[0].split(':')[1];
                parts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
            }

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ contents: [{ parts: parts }] })
            });
            
            const data = await response.json();
            if (data.error) throw new Error(data.error.message || "Unknown API Error");

            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
            
            if (['explain', 'enhance', 'critique', 'transcribe'].includes(mode)) return text;

            try {
              const cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();
              const json = JSON.parse(cleanText);
              return mode === 'flow' ? (json.steps || json) : json;
            } catch (e) {
              console.warn("JSON parse error", e);
              return mode === 'flow' ? [] : text.split('\n').filter(l => l.length > 0);
            }
          } catch (error) {
            console.error("AI Request Failed", error);
            throw error; 
          }
        };

        // --- Helpers ---
        const openDB = () => new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (e) => { if (!e.target.result.objectStoreNames.contains(STORE_NAME)) e.target.result.createObjectStore(STORE_NAME); };
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        const saveStateToDB = async (state) => { const db = await openDB(); return new Promise((resolve, reject) => { const tx = db.transaction(STORE_NAME, 'readwrite'); tx.objectStore(STORE_NAME).put(state, STATE_KEY); tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); }); };
        const loadStateFromDB = async () => { const db = await openDB(); return new Promise((resolve, reject) => { const tx = db.transaction(STORE_NAME, 'readonly'); const req = tx.objectStore(STORE_NAME).get(STATE_KEY); req.onsuccess = () => resolve(req.result); req.onerror = () => reject(req.error); }); };
        const clearDB = async () => { const db = await openDB(); return new Promise((resolve, reject) => { const tx = db.transaction(STORE_NAME, 'readwrite'); tx.objectStore(STORE_NAME).delete(STATE_KEY); tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); }); };

        const fileToBase64 = (file) => new Promise((resolve, reject) => { const r = new FileReader(); r.readAsDataURL(file); r.onload = () => resolve(r.result); r.onerror = e => reject(e); });
        const fileToText = (file) => new Promise((resolve, reject) => { const r = new FileReader(); r.readAsText(file); r.onload = () => resolve(r.result); r.onerror = e => reject(e); });

        const Wire = ({ id, start, end, status = 'default', isSelected, onSelect, onContextMenu }) => {
          const dist = Math.abs(end.x - start.x);
          const controlPointX = Math.max(dist * 0.5, 50); 
          const path = `M ${start.x} ${start.y} C ${start.x + controlPointX} ${start.y}, ${end.x - controlPointX} ${end.y}, ${end.x} ${end.y}`;
          let strokeColor = '#777', strokeWidth = 3, strokeDash = '', shadowOpacity = 0.2;
          if (isSelected) { strokeColor = COLORS.wireSelected; strokeWidth = 4; shadowOpacity = 0.6; }
          else if (status === 'active') { strokeColor = COLORS.wireActive; strokeWidth = 5; shadowOpacity = 0.4; }
          else if (status === 'locked') { strokeColor = '#ef4444'; strokeDash = '10,5'; strokeWidth = 3; }
          else { strokeColor = '#999'; strokeWidth = 3; }
          return (
            <g onClick={(e) => { e.stopPropagation(); onSelect(id); }} onContextMenu={(e) => { e.preventDefault(); e.stopPropagation(); onContextMenu(e, id); }} className="group">
              <path d={path} fill="none" stroke="transparent" strokeWidth={25} style={{ cursor: 'pointer', pointerEvents: 'stroke' }} />
              <path d={path} fill="none" stroke="#000" strokeWidth={strokeWidth + 3} strokeOpacity={shadowOpacity} strokeLinecap="round" className="pointer-events-none" />
              <path d={path} fill="none" stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray={strokeDash} strokeLinecap="round" className="transition-colors duration-200 pointer-events-none" />
            </g>
          );
        };

        // --- Main App ---
        function FlowDo() {
          const [nodes, setNodes] = useState(initialNodes);
          const [edges, setEdges] = useState(initialEdges);
          const [groups, setGroups] = useState(initialGroups);
          const [viewport, setViewport] = useState({ x: 0, y: 0, zoom: 1 });
          const [selection, setSelection] = useState(null); 
          const [contextMenu, setContextMenu] = useState(null); 
          const [aiMenu, setAiMenu] = useState(null); 
          const [saveStatus, setSaveStatus] = useState('loading');
          const [isDbReady, setIsDbReady] = useState(false);
          const [showSettings, setShowSettings] = useState(false);
          const [showTopicModal, setShowTopicModal] = useState(false);
          const [topicInput, setTopicInput] = useState('');
          const [apiKey, setApiKey] = useState(() => localStorage.getItem(SETTINGS_KEY) || '');
          const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
          const [isDraggingNode, setIsDraggingNode] = useState(null); 
          const [isResizingNode, setIsResizingNode] = useState(null); 
          const [isDraggingGroup, setIsDraggingGroup] = useState(null); 
          const [isResizingGroup, setIsResizingGroup] = useState(null);
          const [attachingNodeId, setAttachingNodeId] = useState(null);
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
          const [connecting, setConnecting] = useState(null); 
          const [isAiLoading, setIsAiLoading] = useState(false);
          const mouseDownPos = useRef(null); 
          const fileInputRef = useRef(null);
          const canvasRef = useRef(null);

          useEffect(() => { const i = async () => { try { const s = await loadStateFromDB(); if(s) { setNodes(s.nodes); setEdges(s.edges); setGroups(s.groups); setViewport(s.viewport); } setSaveStatus('saved'); } catch(e){setSaveStatus('error')} finally{setIsDbReady(true)} }; i(); }, []);
          useEffect(() => { if(!isDbReady)return; const t = setTimeout(async()=>{ try{ setSaveStatus('saving'); await saveStateToDB({nodes,edges,groups,viewport}); setSaveStatus('saved'); }catch(e){setSaveStatus('error')} }, 200); return ()=>clearTimeout(t); }, [nodes,edges,groups,viewport,isDbReady]);

          // --- AI HANDLER ---
          const handleAIOperation = async (operation, nodeId) => {
            setAiMenu(null); setIsAiLoading(true);
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const prompt = node.title + (node.data.label ? ": " + node.data.label : "");
            const attachment = node.data.attachments?.find(a => ['text','image','audio'].includes(a.fileType));

            try {
              if (['enhance', 'explain', 'critique', 'transcribe'].includes(operation)) {
                 const textResult = await generateAIContent(operation, prompt, apiKey, attachment);
                 const labelUpdate = operation === 'transcribe' ? (node.data.label + "\n\n-- Transcript --\n" + textResult) : (operation === 'critique' ? (node.data.label) : (node.data.label + "\n\n-- AI --\n" + textResult));
                 
                 // For critique, create a NEW node. For others, append text.
                 if (operation === 'critique') {
                    const newNodeId = `ai-crit-${Date.now()}`;
                    setNodes(prev => [...prev, {
                        id: newNodeId, type: 'note', title: 'Feedback',
                        x: node.x + node.width + 50, y: node.y, width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT,
                        completed: false, data: { label: textResult, attachments: [] }
                    }]);
                    setEdges(prev => [...prev, { id: `ai-e-${Date.now()}`, source: nodeId, target: newNodeId }]);
                 } else {
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, data: { ...n.data, label: labelUpdate } } : n));
                 }

              } else {
                // List generation (quiz, resources, brainstorm, decompose)
                const items = await generateAIContent(operation, prompt, apiKey, attachment);
                if (Array.isArray(items) && items.length > 0) {
                  const newNodes = []; const newEdges = [];
                  const startX = node.x + node.width + 100;
                  const startY = node.y - ((items.length - 1) * 180) / 2;
                  
                  let targetType = 'task';
                  if (operation === 'quiz') targetType = 'question';
                  else if (operation === 'brainstorm') targetType = 'idea';
                  else if (operation === 'resources') targetType = 'resource';

                  items.forEach((item, index) => {
                    const newNodeId = `ai-${Date.now()}-${index}`;
                    newNodes.push({
                      id: newNodeId, type: targetType, title: operation === 'quiz' ? 'Question' : (operation === 'resources' ? 'Resource' : 'Item'),
                      x: startX, y: startY + (index * 200), width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT,
                      completed: false, data: { label: item, attachments: [] }
                    });
                    newEdges.push({ id: `ai-e-${Date.now()}-${index}`, source: node.id, target: newNodeId });
                  });
                  setNodes(prev => [...prev, ...newNodes]); setEdges(prev => [...prev, ...newEdges]);
                } else { alert("AI returned no suggestions."); }
              }
            } catch (e) { alert(`AI Failed: ${e.message}`); } finally { setIsAiLoading(false); }
          };

          const handleGenerateFlow = async () => {
            if (!topicInput.trim()) return; setShowTopicModal(false); setIsAiLoading(true);
            try {
              const steps = await generateAIContent('flow', topicInput, apiKey);
              if (Array.isArray(steps) && steps.length > 0) {
                const newNodes = []; const newEdges = []; const idMap = {};
                const centerX = -viewport.x + 400; const centerY = -viewport.y + 200;
                steps.forEach(step => { idMap[step.id] = `gen-${Date.now()}-${step.id}`; });
                steps.forEach((step, index) => {
                  newNodes.push({
                    id: idMap[step.id], type: ['lecture','concept','question','summary','task'].includes(step.type) ? step.type : 'lecture',
                    title: step.title || 'Step', x: centerX + (index % 2 === 0 ? 0 : 50), y: centerY + (index * 240),
                    width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT, completed: false, data: { label: step.description || '', attachments: [] }
                  });
                  if (step.dependsOn) step.dependsOn.forEach(depId => { if(idMap[depId]) newEdges.push({ id: `gen-e-${Date.now()}-${depId}-${step.id}`, source: idMap[depId], target: idMap[step.id] }); });
                });
                const newGroup = { id: `g-gen-${Date.now()}`, title: topicInput, x: centerX - 50, y: centerY - 80, width: DEFAULT_NODE_WIDTH + 150, height: (steps.length * 240) + 100, color: COLORS.groupHeader };
                setNodes(prev => [...prev, ...newNodes]); setEdges(prev => [...prev, ...newEdges]); setGroups(prev => [...prev, newGroup]);
              } else { alert("AI could not generate a valid plan."); }
            } catch (e) { alert(`AI Flow Failed: ${e.message}`); } finally { setIsAiLoading(false); setTopicInput(''); }
          };

          // Basic Handlers
          const isNodeInGroup = (n, g) => n.x >= g.x && n.x + (n.width||240) <= g.x + g.width && n.y >= g.y && n.y + (n.height||160) <= g.y + g.height;
          const isNodeLocked = (nid) => { const inc = edges.filter(e => e.target === nid); return inc.length > 0 && !inc.every(e => nodes.find(n => n.id === e.source)?.completed); };
          const deleteNode = (id) => { setNodes(prev => prev.filter(n => n.id !== id)); setEdges(prev => prev.filter(e => e.source !== id && e.target !== id)); setSelection(null); setContextMenu(null); };
          const deleteEdge = (id) => { setEdges(prev => prev.filter(e => e.id !== id)); setSelection(null); setContextMenu(null); };
          const deleteGroup = (id) => { setGroups(prev => prev.filter(g => g.id !== id)); setSelection(null); setContextMenu(null); };
          const deleteAttachment = (nid, aid) => setNodes(prev => prev.map(n => n.id === nid ? { ...n, data: { ...n.data, attachments: n.data.attachments.filter(a => a.id !== aid) } } : n));
          const handleAttachClick = (nid) => { setAttachingNodeId(nid); if (fileInputRef.current) { fileInputRef.current.value=''; fileInputRef.current.click(); } };
          const handleAddLink = (nid) => { const url = window.prompt("URL:"); if(url) setNodes(prev => prev.map(n => n.id === nid ? { ...n, data: { ...n.data, attachments: [...(n.data.attachments||[]), {id:Date.now(), name: url, type:'link', url}] } } : n)); };
          const downloadFlow = () => { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify({nodes,edges,groups,viewport},null,2)], {type:'application/json'})); a.download = 'flowdo-data.json'; a.click(); };
          const saveSettings = () => { localStorage.setItem(SETTINGS_KEY, apiKey); setShowSettings(false); alert("Saved!"); };

          // --- SMART FILE HANDLER ---
          const handleFileChange = async (e) => {
            const file = e.target.files[0]; if (!file || !attachingNodeId) return;
            try { 
              setSaveStatus('saving'); 
              let attachmentData = { id: Date.now(), name: file.name, type: 'file' };
              
              if (file.type.startsWith('image/')) {
                  const url = await fileToBase64(file);
                  attachmentData = { ...attachmentData, fileType: 'image', url };
              } else if (file.type.startsWith('audio/')) {
                  const url = await fileToBase64(file);
                  attachmentData = { ...attachmentData, fileType: 'audio', url };
              } else if (file.type === 'text/plain' || file.name.endsWith('.md') || file.name.endsWith('.txt')) {
                  const content = await fileToText(file);
                  attachmentData = { ...attachmentData, fileType: 'text', content };
              } else {
                  const url = await fileToBase64(file);
                  attachmentData = { ...attachmentData, fileType: 'other', url };
              }

              setNodes(prev => prev.map(n => n.id === attachingNodeId ? { ...n, data: { ...n.data, attachments: [...(n.data.attachments||[]), attachmentData] } } : n));
            } catch (err) { alert("File processing error"); }
            setAttachingNodeId(null);
          };

          // Mouse/Wheel Handlers
          const handleWheel = (e) => { if (e.ctrlKey||e.metaKey) { e.preventDefault(); setViewport(p => ({ ...p, zoom: Math.min(Math.max(p.zoom - e.deltaY * 0.001, 0.2), 3) })); } else { setViewport(p => ({ ...p, x: p.x - e.deltaX, y: p.y - e.deltaY })); } };
          const handleMouseDown = (e) => { if ([0,1,2].includes(e.button)) { mouseDownPos.current = {x:e.clientX, y:e.clientY}; if(e.button===0) { setSelection(null); setContextMenu(null); setAiMenu(null); } } };
          const handleMouseMove = (e) => {
            if (mouseDownPos.current && !isDraggingCanvas && !isDraggingNode && !isDraggingGroup && !isResizingNode && !isResizingGroup && !connecting) {
              if (Math.abs(e.clientX - mouseDownPos.current.x) > 5 || Math.abs(e.clientY - mouseDownPos.current.y) > 5) { setIsDraggingCanvas(true); setDragStart({ x: e.clientX, y: e.clientY }); }
            }
            if (isDraggingCanvas) { setViewport(p => ({ ...p, x: p.x + (e.clientX - dragStart.x), y: p.y + (e.clientY - dragStart.y) })); setDragStart({ x: e.clientX, y: e.clientY }); }
            if (isDraggingNode) { setNodes(p => p.map(n => n.id === isDraggingNode ? { ...n, x: n.x + (e.clientX - dragStart.x)/viewport.zoom, y: n.y + (e.clientY - dragStart.y)/viewport.zoom } : n)); setDragStart({ x: e.clientX, y: e.clientY }); }
            if (isDraggingGroup) { 
                const dx = (e.clientX - dragStart.x)/viewport.zoom; const dy = (e.clientY - dragStart.y)/viewport.zoom;
                setGroups(p => p.map(g => g.id === isDraggingGroup.id ? { ...g, x: g.x + dx, y: g.y + dy } : g));
                setNodes(p => p.map(n => isDraggingGroup.capturedNodes.includes(n.id) ? { ...n, x: n.x + dx, y: n.y + dy } : n)); setDragStart({ x: e.clientX, y: e.clientY }); 
            }
            if (isResizingNode) { setNodes(p => p.map(n => n.id === isResizingNode ? { ...n, width: Math.max(180, n.width + (e.clientX - dragStart.x)/viewport.zoom), height: Math.max(120, n.height + (e.clientY - dragStart.y)/viewport.zoom) } : n)); setDragStart({ x: e.clientX, y: e.clientY }); }
            if (isResizingGroup) { setGroups(p => p.map(g => g.id === isResizingGroup ? { ...g, width: Math.max(200, g.width + (e.clientX - dragStart.x)/viewport.zoom), height: Math.max(150, g.height + (e.clientY - dragStart.y)/viewport.zoom) } : g)); setDragStart({ x: e.clientX, y: e.clientY }); }
            if (connecting) { const r = canvasRef.current.getBoundingClientRect(); setConnecting(p => ({ ...p, currentX: (e.clientX - r.left - viewport.x)/viewport.zoom, currentY: (e.clientY - r.top - viewport.y)/viewport.zoom })); }
          };
          const handleMouseUp = () => { setIsDraggingCanvas(false); setIsDraggingNode(null); setIsDraggingGroup(null); setIsResizingNode(null); setIsResizingGroup(null); setConnecting(null); mouseDownPos.current = null; };
          const handleContextMenu = (e) => { e.preventDefault(); if(isDraggingCanvas) return; const r = canvasRef.current.getBoundingClientRect(); setContextMenu({ x: e.clientX, y: e.clientY, viewportX: (e.clientX - r.left - viewport.x)/viewport.zoom, viewportY: (e.clientY - r.top - viewport.y)/viewport.zoom, type: 'canvas' }); setAiMenu(null); };
          
          const handleNodeMouseDown = (e, id) => { e.stopPropagation(); if (e.button === 0) { setIsDraggingNode(id); setDragStart({ x: e.clientX, y: e.clientY }); setSelection(id); setContextMenu(null); setAiMenu(null); } };
          const handleGroupMouseDown = (e, group) => { e.stopPropagation(); if (e.button === 0) { const cn = nodes.filter(n => isNodeInGroup(n, group)).map(n => n.id); setIsDraggingGroup({ id: group.id, capturedNodes: cn }); setDragStart({ x: e.clientX, y: e.clientY }); setSelection(group.id); setContextMenu(null); setAiMenu(null); } };
          const handleResizeMouseDown = (e, id, type) => { e.stopPropagation(); e.preventDefault(); if (e.button === 0) { type === 'node' ? setIsResizingNode(id) : setIsResizingGroup(id); setDragStart({ x: e.clientX, y: e.clientY }); setSelection(id); setContextMenu(null); } };
          const handlePinMouseDown = (e, nid, type) => { e.stopPropagation(); if (e.button === 0) { const r = e.target.getBoundingClientRect(); setConnecting({ source: nid, x: (r.left + r.width/2 - viewport.x)/viewport.zoom, y: (r.top + r.height/2 - viewport.y)/viewport.zoom }); } };
          const handlePinMouseUp = (e, tid, type) => { e.stopPropagation(); if (connecting && type === 'input' && connecting.source !== tid) { if (!edges.find(edge => edge.source === connecting.source && edge.target === tid)) setEdges(prev => [...prev, { id: `e-${Date.now()}`, source: connecting.source, target: tid }]); setConnecting(null); } };
          const handleEdgeContextMenu = (e, eid) => { setSelection(eid); setContextMenu({ x: e.clientX, y: e.clientY, type: 'edge', targetId: eid }); setAiMenu(null); };
          const addNode = (type) => { if (!contextMenu) return; const t = {task:'Task',event:'Event',goal:'Goal',note:'Note',idea:'Idea',condition:'Condition',resource:'Resource',lecture:'Lecture',concept:'Concept',question:'Question',summary:'Summary'}; setNodes(p => [...p, { id: `n-${Date.now()}`, type, title: t[type]||'Node', x: contextMenu.viewportX, y: contextMenu.viewportY, width: DEFAULT_NODE_WIDTH, height: DEFAULT_NODE_HEIGHT, completed: false, data: { label: '', attachments: [] } }]); setContextMenu(null); };
          const addGroup = () => { if (!contextMenu) return; setGroups(p => [...p, { id: `g-${Date.now()}`, title: 'New Group', x: contextMenu.viewportX, y: contextMenu.viewportY, width: 400, height: 300, color: COLORS.groupHeader }]); setContextMenu(null); };
          const getPinPos = (node, type) => { const y = 61; const w = node.width || DEFAULT_NODE_WIDTH; return type === 'input' ? { x: node.x, y: node.y + y } : { x: node.x + w, y: node.y + y }; };

          if (!isDbReady) return <div className="w-full h-screen bg-zinc-950 flex items-center justify-center text-white"><Database className="animate-pulse mr-2" /> Loading Database...</div>;

          return (
            <div className="w-full h-screen overflow-hidden bg-zinc-950 text-white font-sans select-none relative" onContextMenu={handleContextMenu}>
              <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" />
              {showSettings && (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center backdrop-blur-sm">
                  <div className="bg-zinc-900 border border-zinc-700 p-6 rounded-lg w-96 shadow-xl">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2"><Settings className="w-5 h-5" /> Settings</h2>
                    <div className="mb-4">
                      <label className="block text-sm text-zinc-400 mb-2">Google Gemini API Key</label>
                      <input type="password" className="w-full bg-zinc-800 border border-zinc-700 rounded p-2 text-sm focus:outline-none focus:border-blue-500" placeholder="Demo Mode if empty" value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
                    </div>
                    <div className="flex justify-end gap-2"><button onClick={() => setShowSettings(false)} className="px-3 py-1.5 text-sm hover:bg-zinc-800 rounded">Cancel</button><button onClick={saveSettings} className="px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-500 rounded font-medium">Save</button></div>
                  </div>
                </div>
              )}
              {showTopicModal && (
                <div className="fixed inset-0 bg-black/60 z-[100] flex items-center justify-center backdrop-blur-sm">
                  <div className="bg-zinc-900 border border-zinc-700 p-6 rounded-lg w-96 shadow-2xl">
                    <h2 className="text-xl font-bold mb-4 flex items-center gap-2 text-purple-400"><BookOpen className="w-5 h-5" /> Create Study Plan</h2>
                    <textarea className="w-full bg-zinc-800 border border-zinc-700 rounded p-3 text-sm focus:outline-none focus:border-purple-500 min-h-[80px]" placeholder="Topic..." value={topicInput} onChange={(e) => setTopicInput(e.target.value)} />
                    <div className="flex justify-end gap-2 mt-4"><button onClick={() => setShowTopicModal(false)} className="px-3 py-1.5 text-sm hover:bg-zinc-800 rounded">Cancel</button><button onClick={handleGenerateFlow} disabled={!topicInput.trim()} className="px-3 py-1.5 text-sm bg-purple-600 hover:bg-purple-500 disabled:opacity-50 rounded font-medium flex items-center gap-2">{isAiLoading ? 'Generating...' : 'Generate'} <Wand2 size={14}/></button></div>
                  </div>
                </div>
              )}
              <div className="absolute top-4 left-4 z-50 pointer-events-none">
                <h1 className="text-3xl font-bold tracking-tighter text-white opacity-80 flex items-center gap-2"><GraduationCap className="w-8 h-8 text-indigo-500" /> FlowDo <span className="text-sm font-normal text-zinc-500">Learning</span></h1>
                <p className="text-zinc-500 text-sm mt-1">Right-click: Add Nodes | Wand: AI Tools</p>
              </div>
              <div className="absolute top-4 right-4 z-50 flex gap-2 pointer-events-auto items-center">
                <div className={`text-xs mr-2 font-mono ${saveStatus === 'error' ? 'text-red-500' : 'text-zinc-500'}`}>{saveStatus === 'saving' ? 'Saving...' : (saveStatus === 'error' ? 'Error!' : 'Saved')}</div>
                <button onClick={() => setShowTopicModal(true)} className="bg-purple-600/20 hover:bg-purple-600/40 text-purple-300 border border-purple-500/50 px-3 py-1.5 rounded-md text-xs font-medium transition-colors flex items-center gap-2"><Sparkles size={14} /> Plan</button>
                <button onClick={() => setShowSettings(true)} className="p-1.5 bg-zinc-800 hover:bg-zinc-700 rounded-md border border-zinc-700 text-zinc-300"><Settings size={16} /></button>
                <button onClick={downloadFlow} className="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 px-3 py-1.5 rounded-md text-xs font-medium border border-zinc-700 transition-colors"><Download size={14} /></button>
                <button onClick={async () => { if(window.confirm('Reset?')) { await clearDB(); window.location.reload(); }}} className="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 px-3 py-1.5 rounded-md text-xs font-medium border border-zinc-700">Reset</button>
              </div>
              <div ref={canvasRef} className="w-full h-full cursor-grab active:cursor-grabbing" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onWheel={handleWheel} style={{ backgroundSize: `${GRID_SIZE * viewport.zoom}px ${GRID_SIZE * viewport.zoom}px`, backgroundPosition: `${viewport.x}px ${viewport.y}px`, backgroundImage: `linear-gradient(${COLORS.grid} 1px, transparent 1px), linear-gradient(90deg, ${COLORS.grid} 1px, transparent 1px)` }}>
                <div className="w-full h-full origin-top-left transition-transform duration-75 ease-out" style={{ transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.zoom})` }}>
                  {groups.map(group => {
                    const isSelected = selection === group.id;
                    return (
                      <div key={group.id} className="absolute border flex flex-col group/groupbox" style={{ left: group.x, top: group.y, width: group.width, height: group.height, backgroundColor: COLORS.groupBg, borderColor: isSelected ? '#ffffff' : 'rgba(255,255,255,0.1)', borderRadius: '16px', zIndex: 0 }} onMouseDown={(e) => handleGroupMouseDown(e, group)}>
                        <div className="px-4 py-2 rounded-t-2xl font-bold text-lg text-white/50 hover:text-white transition-colors cursor-grab active:cursor-grabbing" style={{ backgroundColor: group.color }}>
                          <input value={group.title} onChange={(e) => setGroups(groups.map(g => g.id === group.id ? { ...g, title: e.target.value } : g))} className="bg-transparent border-none focus:outline-none w-full cursor-text" onMouseDown={(e) => e.stopPropagation()} />
                        </div>
                        <div className="absolute bottom-2 right-2 w-6 h-6 cursor-nwse-resize flex items-center justify-center text-zinc-600 hover:text-white z-10" onMouseDown={(e) => handleResizeMouseDown(e, group.id, 'group')}><GripHorizontal size={20} className="rotate-45" /></div>
                      </div>
                    );
                  })}
                  <svg className="absolute top-0 left-0 overflow-visible pointer-events-none w-1 h-1" style={{ zIndex: 10 }}>
                    {edges.map(edge => {
                      const source = nodes.find(n => n.id === edge.source); const target = nodes.find(n => n.id === edge.target);
                      if (!source || !target) return null;
                      const start = getPinPos(source, 'output'); const end = getPinPos(target, 'input');
                      const status = isNodeLocked(target.id) ? 'locked' : (source.completed ? 'active' : 'default');
                      return <Wire key={edge.id} id={edge.id} start={start} end={end} status={status} isSelected={selection === edge.id} onSelect={setSelection} onContextMenu={handleEdgeContextMenu} />;
                    })}
                    {connecting && connecting.currentX && <Wire start={getPinPos(nodes.find(n => n.id === connecting.source), 'output')} end={{ x: connecting.currentX, y: connecting.currentY }} status="default" id="dragging-wire" onSelect={() => {}} onContextMenu={() => {}} />}
                  </svg>
                  {nodes.map(node => {
                    const isLocked = isNodeLocked(node.id); const isSelected = selection === node.id;
                    let headerColor = COLORS.nodeHeaderTask;
                    if (node.type === 'event') headerColor = COLORS.nodeHeaderGoal; if (node.type === 'goal') headerColor = COLORS.nodeHeaderGoal;
                    if (node.type === 'note') headerColor = COLORS.nodeHeaderNote; if (node.type === 'lecture') headerColor = COLORS.nodeHeaderLecture;
                    if (node.type === 'concept') headerColor = COLORS.nodeHeaderConcept; if (node.type === 'question') headerColor = COLORS.nodeHeaderQuestion;
                    if (node.type === 'summary') headerColor = COLORS.nodeHeaderSummary; if (node.type === 'resource') headerColor = COLORS.nodeHeaderResource;
                    return (
                      <div key={node.id} className="absolute flex flex-col rounded-lg shadow-xl border overflow-hidden group transition-shadow duration-200" style={{ left: node.x, top: node.y, width: node.width || DEFAULT_NODE_WIDTH, height: node.height || DEFAULT_NODE_HEIGHT, backgroundColor: 'rgba(20, 20, 20, 0.95)', borderColor: isSelected ? '#3b82f6' : (isLocked ? '#7f1d1d' : '#333'), borderWidth: isSelected ? '2px' : '1px', opacity: isLocked ? 0.6 : 1, backdropFilter: 'blur(8px)', zIndex: 20 }} onMouseDown={(e) => handleNodeMouseDown(e, node.id)}>
                        <div className="px-3 py-2 text-xs font-bold text-white uppercase tracking-wider flex justify-between items-center shrink-0" style={{ background: `linear-gradient(90deg, ${headerColor}cc 0%, ${headerColor}00 100%)`, borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                          <span className="flex items-center gap-2">
                            {node.type === 'lecture' && <Presentation size={12} />} {node.type === 'concept' && <Lightbulb size={12} />}
                            {node.type === 'question' && <HelpCircle size={12} />} {node.type === 'summary' && <FileText size={12} />}
                            {(node.type === 'task' || node.type === 'event') && <CheckCircle size={12} />}
                            {node.title}
                          </span>
                          <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity"><button onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }} className="hover:text-red-400"><Trash2 size={12} /></button></div>
                        </div>
                        <div className="p-3 text-sm relative flex flex-col flex-grow h-full overflow-hidden">
                          {node.type !== 'event' && <div className="absolute left-[-21px] top-2 p-3 cursor-crosshair z-10 group/pin" title="Input" onMouseDown={(e) => e.stopPropagation()} onMouseUp={(e) => handlePinMouseUp(e, node.id, 'input')}><div className="w-4 h-4 rounded-full bg-white border-2 border-zinc-800 group-hover/pin:scale-150 transition-transform shadow-sm"></div></div>}
                          {node.type !== 'goal' && node.type !== 'note' && <div className="absolute right-[-21px] top-2 p-3 cursor-crosshair z-10 group/pin" title="Output" onMouseDown={(e) => handlePinMouseDown(e, node.id, 'output')}><div className="w-4 h-4 rounded-full border-2 border-zinc-800 group-hover/pin:scale-150 transition-transform shadow-sm" style={{ backgroundColor: node.completed ? '#4ade80' : '#fff' }}></div></div>}
                          <div className="flex flex-col gap-2 flex-grow h-full overflow-hidden">
                            <textarea className="bg-transparent border-none text-zinc-300 focus:text-white focus:outline-none placeholder-zinc-600 w-full resize-none flex-grow text-sm font-mono leading-relaxed p-1 min-h-[40px]" value={node.data.label} onChange={(e) => { const val = e.target.value; setNodes(nodes.map(n => n.id === node.id ? { ...n, data: { ...n.data, label: val } } : n)) }} placeholder="Notes..." onMouseDown={(e) => e.stopPropagation()} />
                            <div className="flex flex-col gap-1 mb-1 max-h-[120px] overflow-y-auto pr-1">
                              {node.data.attachments?.map(att => {
                                 if (att.fileType === 'image') { return (<div key={att.id} className="relative group/image mb-1"><img src={att.url} alt={att.name} className="w-full h-auto max-h-32 object-cover rounded bg-zinc-900 border border-zinc-700" /><div className="absolute top-1 right-1 opacity-0 group-hover/image:opacity-100 transition-opacity"><button onClick={(e) => { e.stopPropagation(); deleteAttachment(node.id, att.id); }} className="p-1 bg-black/50 hover:bg-red-500 rounded text-white"><X size={10} /></button></div><div className="text-[10px] text-zinc-500 truncate px-1 mt-0.5">{att.name}</div></div>); }
                                 if (att.fileType === 'audio') { return (<div key={att.id} className="flex flex-col gap-1 bg-zinc-800 border border-zinc-700 rounded px-2 py-1 text-[10px] max-w-full"><div className="flex items-center gap-1"><Music size={10} className="text-pink-400 shrink-0"/><span className="truncate flex-1 text-zinc-300">{att.name}</span><button onClick={(e) => { e.stopPropagation(); deleteAttachment(node.id, att.id); }} className="hover:text-red-400 shrink-0 ml-1"><X size={10} /></button></div><audio controls src={att.url} className="w-full h-6" /></div>); }
                                 return (<div key={att.id} className="flex items-center gap-1 bg-zinc-800 border border-zinc-700 rounded px-1.5 py-1 text-[10px] max-w-full" title={att.name}>{att.type === 'link' ? <LinkIcon size={10} className="text-blue-400 shrink-0"/> : <FileText size={10} className="text-zinc-400 shrink-0"/>}<a href={att.url} target="_blank" rel="noopener noreferrer" className="truncate flex-1 hover:underline text-zinc-300 hover:text-white" onMouseDown={e => e.stopPropagation()}>{att.name}</a><button onClick={(e) => { e.stopPropagation(); deleteAttachment(node.id, att.id); }} className="hover:text-red-400 shrink-0 ml-1"><X size={10} /></button></div>);
                              })}
                            </div>
                            {node.type !== 'note' && (
                              <div className="flex items-center gap-2 mt-auto pt-2 border-t border-zinc-800 shrink-0">
                                <button onClick={(e) => { e.stopPropagation(); handleAttachClick(node.id); }} className="p-1 rounded bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700 transition-colors"><Paperclip size={12} /></button>
                                <button onClick={(e) => { e.stopPropagation(); handleAddLink(node.id); }} className="p-1 rounded bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700 transition-colors"><LinkIcon size={12} /></button>
                                <button onClick={(e) => { e.stopPropagation(); setAiMenu({ nodeId: node.id, x: e.clientX, y: e.clientY }); }} className="p-1 rounded bg-zinc-800 text-indigo-400 hover:text-indigo-200 hover:bg-zinc-700 transition-colors"><Sparkles size={12} /></button>
                                <button onClick={(e) => { e.stopPropagation(); if (!isLocked) setNodes(nodes.map(n => n.id === node.id ? { ...n, completed: !n.completed } : n)); }} disabled={isLocked} className={`flex-1 py-1 px-2 rounded flex items-center justify-center gap-2 text-xs font-semibold transition-all ${isLocked ? 'bg-zinc-900 text-zinc-600 cursor-not-allowed' : (node.completed ? 'bg-green-900/50 text-green-400 hover:bg-green-900/70' : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-white')}`}>{isLocked ? <Lock size={12} /> : (node.completed ? <CheckCircle size={12} /> : <Circle size={12} />)} {isLocked ? 'LOCKED' : (node.completed ? 'DONE' : 'MARK DONE')}</button>
                              </div>
                            )}
                          </div>
                          <div className="absolute bottom-0 right-0 w-6 h-6 cursor-nwse-resize flex items-center justify-center text-zinc-600 hover:text-zinc-400 z-20" onMouseDown={(e) => handleResizeMouseDown(e, node.id, 'node')}><GripHorizontal size={14} className="rotate-45" /></div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              {contextMenu && (
                <div className="fixed bg-zinc-900 border border-zinc-700 shadow-2xl rounded-lg p-1 min-w-[160px] z-[60] flex flex-col gap-1 text-sm text-zinc-300 animate-in fade-in zoom-in duration-100" style={{ top: contextMenu.y, left: contextMenu.x }} onClick={(e) => e.stopPropagation()}>
                  {contextMenu.type === 'edge' ? ( <button onClick={() => deleteEdge(contextMenu.targetId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-red-900/50 hover:text-red-400 rounded text-left"><Unplug size={14} /> Disconnect</button> ) : (
                    <>
                      <div className="px-2 py-1 text-xs text-zinc-500 font-semibold uppercase tracking-wider">Learning</div>
                      <button onClick={() => addNode('lecture')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><Presentation size={14} className="text-violet-500" /> Lecture Note</button>
                      <button onClick={() => addNode('concept')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><Lightbulb size={14} className="text-cyan-500" /> Concept</button>
                      <button onClick={() => addNode('question')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><HelpCircle size={14} className="text-rose-500" /> Question</button>
                      <button onClick={() => addNode('summary')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><FileText size={14} className="text-amber-500" /> Summary</button>
                      <div className="h-px bg-zinc-800 my-0.5"></div>
                      <div className="px-2 py-1 text-xs text-zinc-500 font-semibold uppercase tracking-wider">Action</div>
                      <button onClick={() => addNode('task')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><CheckCircle size={14} className="text-blue-500" /> Task</button>
                      <button onClick={() => addNode('resource')} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><FolderOpen size={14} className="text-gray-400" /> Resource</button>
                      <button onClick={() => addGroup()} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><BoxSelect size={14} /> Group</button>
                    </>
                  )}
                </div>
              )}
              {aiMenu && (
                 <div className="fixed bg-zinc-900 border border-indigo-500/30 shadow-2xl shadow-indigo-900/20 rounded-lg p-1 min-w-[170px] z-[60] flex flex-col gap-1 text-sm text-zinc-300 animate-in fade-in zoom-in duration-100" style={{ top: aiMenu.y - 140, left: aiMenu.x + 20 }} onClick={(e) => e.stopPropagation()}>
                   <div className="px-2 py-1 text-xs text-indigo-400 font-semibold uppercase tracking-wider flex items-center gap-2"><Sparkles size={12} /> AI Tutor</div>
                   <button onClick={() => handleAIOperation('explain', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><GraduationCap className="w-4 h-4 text-cyan-400" /> Explain</button>
                   <button onClick={() => handleAIOperation('quiz', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><HelpCircle className="w-4 h-4 text-rose-400" /> Quiz Me</button>
                   <button onClick={() => handleAIOperation('decompose', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><SplitIcon className="w-4 h-4 text-blue-400" /> Break Down</button>
                   <button onClick={() => handleAIOperation('enhance', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><Zap className="w-4 h-4 text-amber-400" /> Enhance</button>
                   <div className="h-px bg-zinc-800 my-0.5"></div>
                   <button onClick={() => handleAIOperation('resources', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><Library className="w-4 h-4 text-emerald-400" /> Suggest Resources</button>
                   <button onClick={() => handleAIOperation('critique', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><CheckSquare className="w-4 h-4 text-orange-400" /> Critique & Grade</button>
                   {/* Conditional Transcribe Button */}
                   {nodes.find(n => n.id === aiMenu.nodeId)?.data.attachments?.some(a => a.fileType === 'audio') && (
                     <button onClick={() => handleAIOperation('transcribe', aiMenu.nodeId)} className="flex items-center gap-2 px-2 py-1.5 hover:bg-zinc-800 rounded text-left"><Mic className="w-4 h-4 text-pink-400" /> Transcribe Audio</button>
                   )}
                 </div>
              )}
              {isAiLoading && <div className="fixed top-20 left-1/2 -translate-x-1/2 bg-indigo-900/80 backdrop-blur text-indigo-100 px-4 py-2 rounded-full text-sm font-medium z-[100] animate-pulse shadow-lg flex items-center gap-2"><Sparkles size={16} /> AI Thinking...</div>}
            </div>
          );
        }

        const SplitIcon = ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M12 3v18"/><path d="M3 12h18"/></svg>;

        const container = document.getElementById('root');
        const root = createRoot(container);
        root.render(<FlowDo />);
    </script>
</body>
</html>